# Core
#
# Class for data about the MOC representation of the TREAT core

import pickle
import openmc
from openmc import openmoc_compatible as compatible
import openmoc
from openmoc import checkvalue as cv
from . import constants


class Core:
	"""MOC Core Builder
	
	Required Parameters:
	--------------------
	openmc_lattice:     openmc.RectLattice; the original core lattice from OpenMC
	xslib:              openmc.mgxs.Library; the cross section data generated by OpenMC
	domain_type:        str; "universe", "cell", or "material". ("material" does nothing yet)
	
	Optional Parameters:  (all disabled by default except ids_fname)
	--------------------
	subdivide:          bool; whether to subdivide Elements that request it
	use_sph:            bool; whether to apply SPH factors to Elements that request it
	use_cmm:            bool; whether to apply CMM corrections to Elements that request it
	                    Only valid in the "universe" domain. IDK if it can be used with SPH.
	crdrings:           bool; whether to apply azimuthal rings to crds in Elements that request it
	fsrsects:           bool; whether to apply azimuthal sectors to crds in Elements that request it
	elements:           dict of {key : treat.moc.Element}; Elements requesting the features above
	ids_fname:          str; file name of ids_to_keys pickle
	                    [Default: consants.IDS_PICKLE --> "ids_to_keys.pkl"]
	"""
	def __init__(self, openmc_lattice, xslib, domain_type,
	             subdivide=False, use_sph=False, use_cmm=False, crdrings=False, fsrsects=False,
	             elements=None, ids_fname=constants.IDS_PICKLE, *args, **kwargs):
		cv.check_type("openmc_lattice", openmc_lattice, openmc.RectLattice)
		
		ids_to_keys_pickle = open(ids_fname, 'rb')
		self.ids_to_keys = pickle.load(ids_to_keys_pickle)
		ids_to_keys_pickle.close()
		self.all_keys = set(self.ids_to_keys.values())
		
		self._openmc_lattice = openmc_lattice
		self._nx, self._ny = openmc_lattice.shape
		self._xslib = xslib
		self._ngroups = xslib.energy_groups.num_groups
		self._domain_type = domain_type
		self._moc_cell = openmoc.Cell()
		self._moc_universe = openmoc.Universe()
		self.subdivide = subdivide
		self.use_sph = use_sph
		self.use_cmm = use_cmm
		self.crdrings = crdrings
		self.fsrsects = fsrsects
		self._elements = {}
		if elements is not None:
			self._elements.update(elements)
	
	def _fetch_domain_xsdict(self, domain_id):
		"""Get the cross section dictionary for this domain
		
		Parameter:
		----------
		domain_id:      int; ID for this Cell, Material, or Universe
		
		Returns:
		--------
		xsdict:         dict of {rxn : array of MGXS}
		
		"""
		xsdict = {}
		for rxn in constants.MOC_TYPES:
			xsdict[rxn] = self._xslib.get_mgxs(domain_id, rxn).get_xs()
		return xsdict
	
	def _populate_material_xs(self, material, xsdict, elem):
		"""Set the MGXS for the specified material
		
		Parameters:
		-----------
		material:       openmoc.Material
		xsdict:         dict of {rxn : array of MGXS}
		elem:           treat.moc.Element containing information about SPH and CMM
		
		"""
		scatter = xsdict["consistent nu-scatter matrix"]
		transport = xsdict["nu-transport"]
		fission = xsdict["fission"]
		nu_fission = xsdict["nu-fission"]
		chi = xsdict["chi"]
		# Apply CMM and/or SPH factors as appropriate
		if elem:
			if self.use_cmm and (self._ngroups in elem.cmm):
				cmmc = elem.cmm[self._ngroups]
				scatter = cmmc.get_corrected_scatter_mgxs(scatter, transport)
				transport = cmmc.get_corrected_transport_mgxs(transport)
			if self.use_sph and (self._ngroups in elem.sph):
				sphf = elem.sph[self._ngroups]
				# Correct these 4, but not chi
				scatter = sphf.get_corrected_mgxs(scatter)
				transport = sphf.get_corrected_mgxs(transport)
				fission = sphf.get_corrected_mgxs(fission)
				nu_fission = sphf.get_corrected_mgxs(nu_fission)
		# Set the MGXS themselves
		material.setSigmaS(scatter.flatten())
		material.setSigmaT(transport.flatten())
		material.setSigmaF(fission.flatten())
		material.setNuSigmaF(nu_fission.flatten())
		material.setChi(chi.flatten())
	
	def _get_universe_cell(self, uid, elem=None):
		"""Create a new MOC cell containing a homogenized core element
		
		Parameters:
		-----------
		uid:        int; Universe.id
		elem:       treat.moc.Element, optional; element containing data for CMM
		            [Default: None]
		
		Returns:
		--------
		new_cell:   openmoc.Cell containing the homogenized cross sections
		
		"""
		new_cell = openmoc.Cell(name="u{}-cell".format(uid))
		name = "Homogenized Material for Universe {}".format(uid)
		new_mat = openmoc.Material(name=name)
		new_mat.setNumEnergyGroups(self._ngroups)
		xsdict = self._fetch_domain_xsdict(uid)
		self._populate_material_xs(new_mat, xsdict, elem)
		new_cell.setFill(new_mat)
		return new_cell
	
	def get_universe_ids(self, keys):
		"""Find the Universe IDs corresponding to some set of keys
		
		Parameters:
		-----------
		keys:       iterable of str; the keys to find the IDs for
		
		"""
		keys = set(keys)
		assert keys <= self.all_keys, \
			"Unable to find keys: {}".format(keys - self.all_keys)
		ids = []
		for test_id, test_key in self.ids_to_keys.items():
			if test_key in keys:
				ids.append(test_id)
		return ids
	
	def get_moc_lattice(self):
		"""Create, populate, and return the OpenMOC core lattice
		
		Takes the original OpenMC lattice, harvests the universes, and applies
		openmc.openmoc_compatible as necessary to translate the geometries.
		This method then populates the MGXS from the xslib, applying CMM corrections
		("universe" domain only) and SPH factors (all) as needed.
		
		This is currently implemented for the "cell" and "universe" domains.
		You can run it with "material" but it won't do anything.
		It is still under construction and NOT well tested.
		
		Returns:
		--------
		openmoc.Lattice; the core lattice with all of the cross sections set.
		
		"""
		# Stage 1: Fetch all the OpenMC universes from the RectLattice
		unique = self._openmc_lattice.get_unique_universes()
		universe_array = self._openmc_lattice.universes
		nx, ny = universe_array.shape  # assumes 2D for now
		# Stage 2: get the MOC universes
		ids_to_moc = {}
		lleft = [-constants.HPITCH]*2
		uright = [constants.HPITCH]*2
		for u, universe in unique.items():
			key = self.ids_to_keys[u]
			if key in self._elements:
				elem = self._elements[key]
			else:
				elem = None
			# Stage 3: Apply MGXS
			if self._domain_type in ("cell", "material"):
				moc_univ = compatible.get_openmoc_universe(universe)
				# Find all the cells to set XS for in this universe
				_tmp_geom = openmoc.Geometry()
				_tmp_geom.setRootUniverse(moc_univ)
				material_cells = _tmp_geom.getAllMaterialCells()
				for c, cell in material_cells.items():
					if self._domain_type == "material":
						mat = cell.getFillMaterial()
						domain_id = mat.getId()
					else:
						mat = openmoc.Material()
						mat.setName(cell.getFillMaterial().getName())
						domain_id = c
					mat.setNumEnergyGroups(self._ngroups)
					xsdict = self._fetch_domain_xsdict(domain_id)
					self._populate_material_xs(mat, xsdict, elem)
					cell.setFill(mat)
					# Apply special features to the control rods.
					if elem and ("<ROD>" in cell.getName()):
						if self.crdrings:
							cell.setNumRings(elem.crdrings)
						if self.fsrsects:
							cell.setNumSectors(elem.fsrsects)
				del _tmp_geom
			elif self._domain_type == "universe":
				# Make a homogenized universe
				new_cell = self._get_universe_cell(u, elem)
				moc_univ = openmoc.Universe(name=key)
				moc_univ.addCell(new_cell)
			else:
				raise NotImplementedError(self._domain_type)
			# Stage 4: Apply the geometry transformations as able
			if elem is not None:
				if elem.division:
					sdiv = openmoc.Subdivider(elem.division, lleft, uright)
					moc_univ = sdiv.get_subdivided_universe(moc_univ)
			ids_to_moc[u] = moc_univ
		
		# At last, populate the MOC lattice
		moc_universes = [[None for _ in range(nx)] for _ in range(ny)]
		for j in range(ny):
			for i in range(nx):
				universe = universe_array[j][i]
				moc_univ = ids_to_moc[universe.id]
				moc_universes[j][i] = moc_univ
		
		moc_lat = openmoc.Lattice()
		moc_lat.setWidth(*self._openmc_lattice.pitch)
		moc_lat.setUniverses([moc_universes])
		return moc_lat
		